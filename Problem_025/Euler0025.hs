module Euler0025 where

import Data.List

{-
  https://projecteuler.net/problem=25
  
  The Fibonacci sequence is defined by the recurrence relation:

  Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
  Hence the first 12 terms will be:

  F1 = 1
  F2 = 1
  F3 = 2
  F4 = 3
  F5 = 5
  F6 = 8
  F7 = 13
  F8 = 21
  F9 = 34
  F10 = 55
  F11 = 89
  F12 = 144
  The 12th term, F12, is the first term to contain three digits.

  What is the index of the first term in the Fibonacci sequence to contain 1000 digits?

  Answer: 4782

  (66133732283924402052944876206149883862582218540770912150854099859468290458530
  854019862039934733047040065328066654099281041327356583292691799439871363871823
  000447177641315114631890918558943477097346183758608031894103690637580881898778
  942962621736661626157989086036905555589473251954890104015760429854674295766609
  684580946302112799959256855763638469046209234112409240124591111666763970465058
  576347655459465681464692079854375504199347255550570115714329073928984468876089
  507574953313095328708093460020534232690439821634290464214341002658243959627897
  996116655603791341417475657906880216833741336091856793794510195212396674478057
  947540005693841844202979414285690525148652602894606393972783419557535417340045
  471981482950658660149201310046878085214083602110982086025749490938761965651336
  439399023728978234271342395264950527433681164079027374087520660263458322709779
  214623088326842296599323049265763033834496776777621649729601661231669284047930
  6680187737608910337658122657075262622220319456797676633847360981,4782)

-}

-- Way too slow implementation, O (n!)
fibDefault:: Integer -> Integer
fibDefault 0 = 0
fibDefault 1 = 1
fibDefault n = fibDefault (n-1) + fibDefault (n-2)

-- Much faster implementation, O (n)
fib :: [Integer]
fib = 0 : 1 : zipWith (+) fib (tail fib)

getFibWithIndex:: [(Integer, Integer)]
getFibWithIndex = zip fib [1..]

getFibWith1000Digits:: (Integer, Integer)
getFibWith1000Digits = last $ takeWhile (\x -> numDigits (fst(x)) < 1000) getFibWithIndex

numDigits :: (Integral b, Num a) => b -> a
numDigits n = fst $ foldr step (1,n) tenToPow2s
  where
    pow2s = iterate (*2) 1
    tenToPow2s = zip pow2s . takeWhile (<=n) . iterate (^2) $ 10
    step (k,t) (d,n) = if n>=t then (d+k, n `div` t) else (d,n)
